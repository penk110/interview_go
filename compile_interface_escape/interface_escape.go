package main

type Shape interface {
	Area() float64
}

type Rectangle struct {
	a float64
	b float64
}

// Area 标记禁止函数内联
//go:noinline
func (rectangle Rectangle) Area() float64 {
	return rectangle.a * rectangle.b
}

func main() {
	var (
		r  Rectangle
		ri Shape
	)
	r = Rectangle{
		a: 10,
		b: 20,
	}

	ri = Shape(r)

	ri.Area()
}

/*
接口内存逃逸分析：
	iface 结构体的data字段存储了接口具体值的指针，其存储的数据大小不能确定，存储在接口中的值必须能够获取其地址，所以栈中分配的值被赋值给接口后
	会发生内存逃逸到堆中，在堆中开辟内存


go tool compile -m interface_escape.go

interface_escape.go:12:6: can inline Rectangle.Area
interface_escape.go:16:6: can inline main
interface_escape.go:26:12: Shape(r) escapes to heap
<autogenerated>:1: inlining call to Rectangle.Area
<autogenerated>:1: .this does not escape
<autogenerated>:1: leaking param: .this


➜  compile_interface_escape git:(master) ✗ go1.14.12 tool compile -S interface_escape.go > s.txt
看不懂汇编-------

汇编对应源码部分：
func convT2Inoptr(tab *itab, elem unsafe.Pointer) (i iface) {
	t := tab._type
	if raceenabled {
		raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2Inoptr))
	}
	if msanenabled {
		msanread(elem, t.size)
	}
	x := mallocgc(t.size, t, false)
	// TODO:
	memmove(x, elem, t.size)
	i.tab = tab
	i.data = x
	return
}
*/
